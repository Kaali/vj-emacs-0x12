-*- mode: org; fill-column: 78 -*-
#+TITLE: Emacs configuration for 2018
#+AUTHOR: Väinö Järvelä
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :comments yes

* Intro

Emacs configuration for year 2018. My [[https://github.com/Kaali/vj-emacs-0f][2015]] configuration has served me
well. But it's time for a new configuration with a bit of a cleanup.

Main features of this configuration is:

1. ob-tangle to create a literate configuration file
2. use-package to handle packages
3. bind-key for shortcuts

Some of the experimental packages are now stable, and some ended up
being unsused. Main changes are:

1. Simplify package management
2. Switch from [[https://github.com/emacs-helm/helm][helm]] to [[https://github.com/abo-abo/swiper][Ivy]]
3. Try to keep startup fast

** Requirements

Requires Emacs 25. Configuration has been tested on macOS and
Linux. Windows not supported at this moment.

Some packages might require external tools such as git, ag, etc.
Especially language support. But they do not block starting Emacs with
this configuration.

** Installation

Keep it simple. Clone as =~/.emacs.d= and done.

** org babel tips

Insert a code block by tuping =<sTAB=.
Use =C-'= to edit code blocks.

* Bootstrap
** Enable lexical binding
#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t; -*-
#+END_SRC

** Benchmark Emacs startup

It's easier to optimize Emacs startup time when I have some data
available. Time code borrowed from [[https://github.com/jwiegley/dot-emacs/blob/master/init.el][John Wiegley's init.el]]

#+BEGIN_SRC emacs-lisp
  (defconst emacs-start-time (current-time))

  (defun display-startup-echo-area-message ())

  (add-hook 'after-init-hook
            `(lambda ()
               (let ((elapsed
                      (float-time
                       (time-subtract (current-time) emacs-start-time))))
                 (message "Loading %s...done (%.3fs) [after-init]"
                          ,load-file-name elapsed))) t)
#+END_SRC

** Startup optimizations
*** Adjust GC in startup

Emacs garbage collector tries to use sane settings for an interactive
environment. It reduced throughput a bit. We can make Emacs start
faster by adjusting GC on startup and then fallback to interactive
settings.

#+BEGIN_SRC emacs-lisp
  (defvar original-gc-cons-threshold gc-cons-threshold)
  (defvar original-gc-cons-percentage gc-cons-percentage)

  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (add-hook 'after-init-hook
            `(lambda () (setq gc-cons-threshold original-gc-cons-threshold
                              gc-cons-percentage original-gc-cons-percentage)) t)

#+END_SRC
*** Remove file handlers on startup

Make startup faster by removing all file handlers for the duration of
the startup. Should not affect initialization with my configuration.

#+BEGIN_SRC emacs-lisp
  (defvar file-name-handler-alist-old file-name-handler-alist)
  (setq file-name-handler-alist nil)
  (add-hook 'after-init-hook
            `(lambda () (setq file-name-handler-alist file-name-handler-alist-old)) t)
#+END_SRC

** Initial frame size

Maximize the initial frame. There will be some flashing unless Emacs
is started with =-mm= command line parameter.

#+BEGIN_SRC emacs-lisp
  (setq initial-frame-alist '((fullscreen . maximized)))
#+END_SRC

** Harden TLS

#+BEGIN_SRC emacs-lisp
  (require 'tls)
  (setq tls-checktrust t)
#+END_SRC

** Use custom file
Use a specific custom file instead of saving things in =init.el= which
is used to bootstrap =org-babel=.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file t)
#+END_SRC

** Setup package management

Setup package.el manually to speed up startup. Adapted from
[[https://github.com/gilbertw1/emacs-literate-starter/blob/master/emacs.org#emacs-initialization][emacs-literate-starter]] and [[https://github.com/nilcons/emacs-use-package-fast][emacs-use-package-fast]].

#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t))

    (eval-and-compile
      (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))

    ;; Add packages to info, required because we haven't run
    ;; package-initialize
    (with-eval-after-load "info"
      (info-initialize)
      (dolist (dir (directory-files package-user-dir))
        (let ((fdir (concat (file-name-as-directory package-user-dir) dir)))
          (unless (or (member dir '("." ".." "archives" "gnupg"))
                      (not (file-directory-p fdir))
                      (not (file-exists-p (concat (file-name-as-directory fdir) "dir"))))
            (add-to-list 'Info-directory-list fdir))))))
#+END_SRC

Initialize package.el and [[https://github.com/jwiegley/use-package][use-package]] only when compiling. But hook up
the initialization if =package-initialize= is called so that package.el
still works.

#+BEGIN_SRC emacs-lisp
  (defun vj--setup-package-el (&optional _)
    (require 'package)
    ;; Make package-installed-p only check the user package dir for org-mode
    ;; to make it skip the bundled org-mode.
    (defun vj--package-installed-p (orig-fn &rest args)
      (if (eq (car args) 'org)
          (if (file-expand-wildcards (concat package-user-dir "/org-[0-9]*")) t nil)
        (apply orig-fn args)))
    (advice-add 'package-installed-p :around #'vj--package-installed-p)

    (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                        (not (gnutls-available-p))))
           (proto (if no-ssl "http" "https")))
      (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
      (add-to-list 'package-archives (cons "org" (concat proto "://orgmode.org/elpa/")) t)
      (setq package-archive-priorities '(("org" . 3)
                                         ("melpa" . 2)
                                         ("gnu" . 1)))))

  (advice-add #'package-initialize :before #'vj--setup-package-el)

  (eval-when-compile
    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package)))

  ;; In init-file-debug mode, enable verbosity and statistics for use-package.
  (eval-and-compile
    (setq use-package-always-ensure t)
    (if init-file-debug
        (setq use-package-verbose t
              use-package-expand-minimally nil
              use-package-compute-statistics t)
      (setq use-package-verbose nil
            use-package-expand-minimally t
            use-package-compute-statistics nil)))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

When running from byte compiled file, setup autoload for =use-package=
so it can be used seamlessly. It also does package-initialize after
load to make sure =package.el= is also initialized.

#+BEGIN_SRC emacs-lisp
  (unless (featurep 'use-package)
    (require 'package)
    (autoload 'use-package "use-package")
    (eval-after-load "use-package" #'package-initialize))
#+END_SRC

Add [[https://github.com/emacsmirror/diminish][diminish]] and bind-key support to =use-package=

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
  (use-package bind-key)
  ; Requires here should speed up the boot
  (require 'diminish)
  (require 'bind-key)
#+END_SRC

* Global configuration

Include mainly emacs configuration, with packages only for theming.

** No littering

Use [[https://github.com/emacscollective/no-littering][no-littering]] to enable wide array of default paths and filenames for modes
that tries to save in .emacs.d directory. And drop my custom paths when
possible.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering)
#+END_SRC

** Basic settings

Load private information out of this repository.

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/private.el")
#+END_SRC

Example file:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq user-full-name "Väinö Järvelä"
        user-mail-address "vaino.jarvela@example.com")
#+END_SRC

Some really basic self-explanatory settings:

#+BEGIN_SRC emacs-lisp
  (setq
   inhibit-startup-message t
   require-final-newline t
   major-mode 'text-mode
   confirm-kill-emacs 'y-or-n-p
   kill-do-not-save-duplicates t)

  (put 'narrow-to-region 'disabled nil)

  (defalias 'yes-or-no-p 'y-or-n-p)

  (setq sentence-end-double-space nil)

  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)

  (setq mouse-yank-at-point t)
  (setq save-interprogram-paste-before-kill t)

  (setq scroll-conservatively 1000
        scroll-margin 0
        scroll-preserve-screen-position t
        hscroll-margin 1
        hscroll-step 1)
#+END_SRC

Revert changed files automatically if I haven't touched them:

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
  (diminish 'auto-revert-mode)
#+END_SRC

Mark-ring is navigable by typing =C-u C-SPC= and then repeating
=C-SPC= forever:

#+BEGIN_SRC emacs-lisp
  (setq set-mark-command-repeat-pop t)
#+END_SRC

When executing shell commands from emacs, set =PATH= correctly. This
slows down Emacs startup quite a lot depending on what the shell does.

For some reason I have to run it twice to get a final =PATH= should
investigate why.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :unless (memq window-system '(w32))
    :config
    (setq exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-initialize))
#+END_SRC

Delete selected text when backspacing:

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC

When splitting windows, resize them all equally instead of just
splitting the active window:

#+BEGIN_SRC emacs-lisp
  (setq window-combination-resize t)
#+END_SRC

Setup backups and history.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC

Emacs 26 has a better auto save system, which actually auto saves the
original file. That it what I actually want of a auto save system. So
on Emacs 26 use the new auto save system and disable backups as they
are not needed anymore. And I have never actually restored a old
backup from Emacs so it's not necessary for that either.

#+BEGIN_SRC emacs-lisp
  (if (>= emacs-major-version 26)
      (progn
        (auto-save-visited-mode t)
        (setq auto-save-timeout 30
              auto-save-interval 0
              make-backup-files nil
              create-lockfiles nil))
    (progn
      (setq delete-old-versions -1)
      (setq version-control t)
      (setq vc-make-backup-files t)
      (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
  ))
#+END_SRC

Also enable out-of-focus auto saving. The timing can be wrong when
switching between shell and Emacs to run commands. So make sure that
all files are saved when Emacs goes out of focus.

#+BEGIN_SRC emacs-lisp
  (when (>= emacs-major-version 26)
      (defun save-some-buffers-without-prompt ()
        (save-some-buffers
         :no-prompt
         (lambda ()
           (not (and buffer-auto-save-file-name
                     auto-save-visited-file-name)))))
      (add-hook 'focus-out-hook #'save-some-buffers-without-prompt))
#+END_SRC

** Indentation

Sadly tabs seems to have lost the indentation war. So let's just use
spaces:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Indent with 4 spaces and set some default styles:

#+BEGIN_SRC emacs-lisp
  (setq c-default-style
        '((java-mode . "java") (awk-mode . "awk") (other . "bsd"))
        c-basic-offset 4)
#+END_SRC

** Compilation

By default Emacs sticks to the bottom of the compilation buffer only
if the user puts the point at the bottom.

Automatic scrolling can be enabled with:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq compilation-scroll-output t)
#+END_SRC

But I like it more that it stops at the first error with:

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+END_SRC

I usually use multiple frames to split my display. So please don't
open more than one compilation buffer:

#+BEGIN_SRC emacs-lisp
  (add-to-list
   'display-buffer-alist
   '("\\*compilation\\*" display-buffer-reuse-window
     (reusable-frames . t)))
#+END_SRC

** Windows settings

Speed up reading sub-process output on Windows. The default setting is
optimized for MS-DOS sub-processes. This is the new default in Emacs
master-branch.

#+BEGIN_SRC emacs-lisp
  (when (boundp 'w32-pipe-read-delay)
    (setq w32-pipe-read-delay 0))
#+END_SRC

** Mac settings

Setup Mac keyboard to be close to Linux.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
    (setq mac-pass-option-to-system nil
          mac-pass-control-to-system nil
          mac-pass-command-to-system nil
          mac-command-key-is-meta t
          mac-option-key-is-meta nil
          mac-command-modifier 'meta
          mac-option-modifier 'control
          mac-control-modifier 'control
          mac-function-modifier 'meta))
#+END_SRC

Use macOS default browser for urls:

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq browse-url-browser-function 'browse-url-default-macosx-browser))
#+END_SRC

I don't like macOS native fullscreen mode, so if I wish to run Emacs
in fullscreen-mode, then fake it rather than using native stuff:

#+BEGIN_SRC emacs-lisp
  (setq ns-use-native-fullscreen nil)
#+END_SRC

** Visual

Set a font.

#+BEGIN_SRC emacs-lisp
  ;; adapted from https://www.emacswiki.org/emacs/SetFonts
  (require 'seq)
  (defun font-candidate (&rest fonts)
    "Return the first available font."
    (seq-find (lambda (x) (find-font (font-spec :name x))) fonts))

  (if (eq system-type 'windows-nt)
      (progn
        (setq inhibit-compacting-font-caches t)
        (set-frame-font (font-candidate "Noto Mono-9" "Input-13" "DejaVu Sans Mono-9" "Consolas-9") nil t))
    (set-frame-font (font-candidate "Noto Mono-12" "Input-13" "DejaVu Sans Mono-9" "Consolas-9") nil t))
  (set-face-attribute 'default (selected-frame))
#+END_SRC

Disable extra emacs cruft.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (unless (eq system-type 'mac)
    (menu-bar-mode -1))
#+END_SRC

Setup a dark theme. Light theme makes the text crisper, but I cannot find
light themes with good contrast while not being glaring.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :demand t
    :config
    (load-theme 'sanityinc-tomorrow-day t))
#+END_SRC

Global settings related to Emacs UI.

#+BEGIN_SRC emacs-lisp
  (setq-default
   ;; Improve performance, especially with long lines or large buffers
   bidi-display-reordering nil
   jit-lock-stealth-nice 0.1
   jit-lock-stealth-time 0.2
   ;; Clean up visual cruft
   indicate-buffer-boundaries nil
   indicate-empty-lines nil)
#+END_SRC

Make the fringe a bit smaller. Looks a lot nicer than the default wide
one when using [[diff-hl]] in the fringe. But it also requires some care
with some fringe bitmaps, which is why I include [[fringe-helper]].

#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)
#+END_SRC

Show column number and buffer size in the modeline.

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
  (size-indication-mode t)
#+END_SRC

Reduce Emacs bells but keep it on as a visual bell.

Previously I tried to flash the modeline but in some cases it made
Emacs slow down a lot. Especially on Windows.

Implementation is based on [[https://www.emacswiki.org/emacs/AlarmBell][AlarmBell Emacs Wiki]].

#+BEGIN_SRC emacs-lisp
  (setq visual-bell 1)
  (setq ring-bell-function
        (lambda ()
          (unless (memq this-command
                        '(isearch-abort
                          abort-recursive-edit 
                          exit-minibuffer
                          keyboard-quit))
            (ding))))
#+END_SRC

Modeline customization. I'm removing the vc-mode stuff as it's usually
out of date with magit.

#+BEGIN_SRC emacs-lisp
  (defun vj--modeline-justify (left right)
    (let* ((l (format-mode-line left))
           (r (format-mode-line right))
           (width (max 0 (- (window-total-width) (string-width l) (string-width r))))
           (fill (make-string width ? )))
      (concat l fill r)))

  (defvar vj--projectile-mode-line)
  (put 'vj--projectile-mode-line 'risky-local-variable t)
  (with-eval-after-load 'projectile
    (setq vj--projectile-mode-line
          '(:propertize
            (:eval (when (projectile-project-p)
                     (concat " [" (projectile-project-name) "]"))))))

  (setq-default mode-line-format
                '((:eval (vj--modeline-justify
                          '("%e"
                            mode-line-front-space
                            mode-line-modified
                            "%4l:%c"
                            vj--projectile-mode-line
                            " %[" mode-line-buffer-identification "%]")
                          '(" "
                            mode-line-modes
                            mode-line-misc-info
                            mode-line-end-spaces)))))
#+END_SRC

** Keyboard
*** Global keyboard

I use this key for switching between windows in a single application
on macOS, but Emacs eats the shortcut when I try to use the same
shortcut for switching between frames:

#+BEGIN_SRC emacs-lisp
  (bind-key "M-`" 'other-frame)
#+END_SRC

Free =C-m= from being return, and bindable as a shortcut:

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map [?\C-m] [C-m])
#+END_SRC

I like to use meta+arrow for moving between windows:

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings 'meta)
#+END_SRC

Setup better defaults for Emacs keybindings:

#+BEGIN_SRC emacs-lisp
  ;; Always reindent on newline
  (bind-key "RET" 'newline-and-indent)

  ;; I want to use regexps by default with query-replace
  (bind-key "M-%" 'query-replace-regexp)
  (bind-key "C-M-%" 'query-replace)

  ;; Kill this buffer by default
  (bind-key "C-x k" 'kill-this-buffer)
  (bind-key "C-x K" 'kill-buffer)

  ;; With control as meta, I need C-/ for completion because of muscle
  ;; memory, and I never use C-z
  (bind-key "C-z" 'undo)
#+END_SRC

I use join-line a lot:

#+BEGIN_SRC emacs-lisp
  (bind-key "M-j" 'join-line)
#+END_SRC

*** Vim-like features

I don't like emacs =zap-to-char= as it eats the char I'm zapping to. I
usually/always want to keep the char I'm zapping to.

#+BEGIN_SRC emacs-lisp
  (defun vj/zap-up-to-char (arg char)
    "Zap up to a character."
    (interactive "p\ncZap up to char: ")
    (zap-to-char arg char)
    (insert char)
    (forward-char -1))

  (bind-key "M-z" 'vj/zap-up-to-char)
#+END_SRC

*** cycle spacing
This requires a bit newer emacs version. It allows you to cycle
between three different whitespace amount around a point:

1. Delete all but one space
2. Delete all space
3. Keep original spaces

#+BEGIN_SRC emacs-lisp
  (bind-key* "C-M-SPC" 'cycle-spacing)
#+END_SRC

** el-patch

Use [[https://github.com/raxod502/el-patch][el-patch]] for modifying package functionality. Provides a safer way
to modify defs by providing validation and diffing capabilities.

#+BEGIN_SRC emacs-lisp
  (use-package el-patch
    :demand t
    :commands (el-patch-defmacro el-patch-defsubst el-patch-defvar
               el-patch-defconst el-patch-defcustom el-patch-defun
               el-patch-define-minor-mode el-patch-feature))
#+END_SRC

** async

Use [[https://github.com/jwiegley/emacs-async][emacs-async]] to compile packages asynchronously.

#+BEGIN_SRC emacs-lisp
  (use-package async
    :config
    (setq async-bytecomp-package-mode t))
#+END_SRC

* Major modes
** Magit

[[https://magit.vc/][Magit]] the magic git integration.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer 5
    :after ivy
    :preface
    (defun vj--demand-magit-if-git-registered ()
      (when (vc-git-registered (buffer-file-name))
        (require 'magit)))
    (add-to-list 'find-file-hook #'vj--demand-magit-if-git-registered)
    :config
    (setq
     magit-completing-read-function 'ivy-completing-read
     magit-save-repository-buffers 'dontask
     magit-wip-after-save-local-mode-lighter nil
     magit-wip-after-apply-mode-lighter nil
     magit-wip-before-change-mode-lighter nil
     magit-no-message '("Turning on magit-auto-revert-mode...")
     git-commit-summary-max-length 50)
    (magit-wip-after-save-mode)
    (magit-wip-after-apply-mode)
    (magit-wip-before-change-mode)
    :bind ("C-x g" . magit-status))
#+END_SRC

Also install [[https://github.com/magit/git-modes][git-modes]] from =Magit= to make editing git files a bit
better. They are actually released as three packages.

#+BEGIN_SRC emacs-lisp
  (use-package gitconfig-mode
    :mode ("/\\.gitconfig\\'"
           "/\\.git/config\\'"
           "/modules/.*/config\\'"
           "/git/config\\'"
           "/\\.gitmodules\\'"
           "/etc/gitconfig\\'"))

  (use-package gitattributes-mode
    :mode ("/\\.gitattributes\\'"
           "/info/attributes\\'"
           "/git/attributes\\'"))

  (use-package gitignore-mode
    :mode ("/\\.gitignore\\'"
           "/info/exclude\\'"
           "/git/ignore\\'"))
#+END_SRC

Use [[https://github.com/magit/ssh-agency/blob/master/ssh-agency.el][ssh-agency]] to handle ssh-agent for git with Windows.

#+BEGIN_SRC emacs-lisp
  (use-package ssh-agency
    :after magit
    :if (eq system-type 'windows-nt))
#+END_SRC

** yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml$")
#+END_SRC

** jinja2

#+BEGIN_SRC emacs-lisp
  (use-package jinja2-mode
    :mode ("\\.j2\\'" . jinja2-mode))
#+END_SRC

** markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md$")
#+END_SRC

** ediff

The default configuration is horrible for window configurations. I
really don't want any package to create new frames for me. And I
usually split my display vertically, so use horizontal splits.

Also add a hook that saves and restores window configurations when I'm
done with =ediff=.

When running ediff from magit, it creates a temporary C -buffer. Emacs
26 auto-save-visited-mode tries to save that buffer and asks for a
filename for it. This seems to be because ediff hooks up
auto-save-mode and touches some buffer local variables which makes
this happen.

So my quick fix is to just override that function when running Emacs
>= 26. This is a hack, but it works for me.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)

  (add-hook 'ediff-load-hook
            (lambda ()
              (when (>= emacs-major-version 26)
                (defun ediff-arrange-autosave-in-merge-jobs (merge-buffer-file)))
              (add-hook 'ediff-before-setup-hook
                        (lambda ()
                          (setq ediff-saved-window-configuration (current-window-configuration))))
              (let ((restore-window-configuration
                     (lambda ()
                       (set-window-configuration ediff-saved-window-configuration))))
                (add-hook 'ediff-quit-hook restore-window-configuration 'append)
                (add-hook 'ediff-suspend-hook restore-window-configuration 'append))))
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :preface
    (defun vj--new-eshell () (interactive) (eshell t))

    ;; isearch things copied from jwiegley's emacs config
    (defvar eshell-isearch-map
      (let ((map (copy-keymap isearch-mode-map)))
        (define-key map [(control ?m)] 'eshell-isearch-return)
        (define-key map [return]       'eshell-isearch-return)
        (define-key map [(control ?r)] 'eshell-isearch-repeat-backward)
        (define-key map [(control ?s)] 'eshell-isearch-repeat-forward)
        (define-key map [(control ?g)] 'eshell-isearch-abort)
        (define-key map [backspace]    'eshell-isearch-delete-char)
        (define-key map [delete]       'eshell-isearch-delete-char)
        map)
      "Keymap used in isearch in Eshell.")

    (defun eshell-initialize ()
      (defun eshell-spawn-external-command (beg end)
        "Parse and expand any history references in current input."
        (save-excursion
          (goto-char end)
          (when (looking-back "&!" beg)
            (delete-region (match-beginning 0) (match-end 0))
            (goto-char beg)
            (insert "spawn "))))

      (add-hook 'eshell-expand-input-functions 'eshell-spawn-external-command)

      (use-package em-unix
        :defer t
        :ensure nil
        :config
        (unintern 'eshell/su nil)
        (unintern 'eshell/sudo nil)))

    ;; Replace default completion with a version that ivy is hooked to.
    ;; Can't use company-mode here as it doesn't really work well with eshell.
    (add-hook 'eshell-mode-hook
              (lambda () 
                (define-key eshell-mode-map (kbd "<tab>")
                  (lambda () (interactive) (pcomplete-std-complete)))))
    :hook (eshell-first-time-mode-hook . eshell-initialize)
    :bind (("C-x m" . eshell)
           ("C-x M" . vj--new-eshell)))
#+END_SRC

** dired

Small dired customizations

#+BEGIN_SRC emacs-lisp
  (use-package dired
    :ensure nil
    :commands dired
    :bind (:map dired-mode-map
                ("M-s f"))
    :config
    (setq dired-auto-revert-buffer t))

  (use-package dired-x
    :ensure nil
    :after dired
    :config
    (setq-default dired-omit-files-p t))
#+END_SRC

Add some colors with [[https://github.com/purcell/diredfl][direfl]]

#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :after dired
    :hook (dired-mode . diredfl-mode))
#+END_SRC

Use [[https://github.com/Fuco1/dired-hacks#dired-collapse][dired-collapse]] to collapse directories with just a single file
into one entry in dired.

#+BEGIN_SRC emacs-lisp
  (use-package dired-collapse
    :after dired
    :hook (dired-mode . dired-collapse-mode))
#+END_SRC

** org

org-mode is excellent, I just use it too little.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind (("C-c a" . org-agenda))
    :mode ("\\.org$" . org-mode)
    :hook (org-mode . auto-fill-mode)
    :config
    (setq org-startup-folded t
          org-startup-with-inline-images t
          org-startup-truncated t
          org-agenda-start-with-log-mode t
          org-directory "~/Documents/org"
          org-default-notes-file (concat org-directory "/notes.org")
          org-replace-disputed-keys t
          org-hide-emphasis-markers t))
#+END_SRC

** Projectile

Project management support.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand t
    :diminish
    :commands projectile-mode
    :preface
    (setq projectile-keymap-prefix (kbd "C-c p"))
    :config
    (setq
     projectile-completion-system 'ivy
     projectile-enable-caching nil
     projectile-indexing-method 'alien
     projectile-mode-line nil)
    (projectile-mode))
#+END_SRC

Projectile counsel support.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :demand t
    :after (counsel projectile)
    :commands (counsel-projectile-find-file
               counsel-projectile-find-dir
               counsel-projectile-switch-to-buffer
               counsel-projectile-grep counsel-projectile-ag
               counsel-projectile)
    :bind (([remap projectile-find-file]        . counsel-projectile-find-file)
           ([remap projectile-find-dir]         . counsel-projectile-find-dir)
           ([remap projectile-switch-to-buffer] . counsel-projectile-switch-to-buffer)
           ([remap projectile-grep]             . counsel-projectile-grep)
           ([remap projectile-ag]               . counsel-projectile-ag)
           ("C-;" . counsel-projectile)))
#+END_SRC

** Python

Default to Python 3 on macOS. Requires installation from homebrew.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq python-shell-interpreter "python3"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("\\.py$" . python-mode)
    :interpreter ("python" . python-mode))
#+END_SRC

Setup Anaconda mode for Python autocomplete and navigation.

NOTE: Anaconda is disabled for now as I'm testing [[eglot]] with
[[https://github.com/palantir/python-language-server][python-language-server]].

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :disabled t
    :after python
    :commands anaconda-mode
    :hook ((python-mode . anaconda-mode)
           (python-mode . anaconda-eldoc-mode)))

  (use-package company-anaconda
    :after (python anaconda-mode)
    :hook (anaconda-mode . (lambda () (add-to-list 'company-backends 'company-anaconda))))
#+END_SRC

** C and C++

I like to use =subword-mode= in C -languages and I don't like when
namespaces in C++ indents the block, as then all my code would be at
indentation level 2.

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
           ("\\(\\.h|\\.c\\)" . c-mode))
    :preface
    (defun my-c-mode-setup ()
      (subword-mode 1)
      (c-set-offset 'innamespace 4))
    :config
    (add-hook 'c-mode-common-hook 'my-c-mode-setup))
#+END_SRC

*** RTags

=irony-mode= has not been a complete success for me, with a lot of
timeouts or just not understanding other than basic method or function
lookup. It's quite nice and easy to setup, but it leaves me wanting
more. So I'm going to try out [[https://github.com/Andersbakken/rtags][rtags]] which is a more complete C++
system, which provides autocomplete, diagnostics, refactoring and
navigation.

The problem is that it's a bit more complicated to setup, and tool
support seems to be a bit lacking vs. separate tools such as
=irony-mode= and =gtags=.

#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :after (company cc-mode)
    :commands rtags-mode
    :config
    (rtags-enable-standard-keybindings c-mode-base-map)
    (setq rtags-display-result-backend 'ivy))
#+END_SRC

*** Irony

For autocomplete use [[https://github.com/Sarcasm/irony-mode][irony-mode]], as it seems to be quite lightweight,
but still quite feature complete. =company-mode= can do completion
quite well without =irony-mode= but with =irony-mode= we get better
project support and other tools.

To get =irony-mode= working, you have to run =irony-install-server=
command, and have =libclang= installed on your system. On a Mac you
can install =libclang= with:

#+BEGIN_SRC sh :tangle no
  $ brew install llvm --with-clang
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package irony
    :after cc-mode
    :init
    (defun my-irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async))
    :hook ((c++-mode c-mode objc-mode) . irony-mode)
    :config
    (add-hook 'irony-mode-hook 'my-irony-mode-hook)
    (require 'irony-cdb)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
    (when (boundp 'w32-pipe-buffer-size)
      (setq irony-server-w32-pipe-buffer-size (* 64 1024))))

  (use-package company-irony
    :after (company irony)
    :config
    (eval-after-load 'company '(add-to-list 'company-backends 'company-irony)))
#+END_SRC

Autocomplete C headers with =company=. Needs some work for project
paths. For now I have just added a single include path from my system
to get C++ headers.

To set user headers, see =company-c-headers-path-user=.

#+BEGIN_SRC emacs-lisp
  (use-package company-c-headers
    :after (company cc-mode)
    :config
    (add-to-list 'company-backends 'company-c-headers))
#+END_SRC

Because =irony= mode can read compile options from multiple different
project styles, it's convenient to use [[https://github.com/Sarcasm/flycheck-irony][flycheck-irony]] for =flycheck=.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-irony
    :after (flycheck irony)
    :config (with-eval-after-load 'flycheck (add-to-list 'flycheck-checkers 'irony)))
#+END_SRC

There is also =irony-eldoc= for seeing function interfaces when you
place the point on top of a function. It can only understand overloads
by arity, but it's better than nothing.

#+BEGIN_SRC emacs-lisp
  (use-package irony-eldoc
    :after (irony eldoc)
    :hook (irony-mode . irony-eldoc))
#+END_SRC

*** CMake
For editing CMake files:

#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
    :mode "CMakeFiles.txt")
#+END_SRC

** Javascript

Use =js2-mode= for syntax highlighting and for the AST that some
packages require. And use [[https://github.com/emacs-lsp/lsp-javascript][lsp-javascript]] for navigation / auto
complete functionality.

Requires [[https://github.com/sourcegraph/javascript-typescript-langserver][Javascript Language Server]] to be installed. Install it with:

#+BEGIN_SRC sh
  npm install -g javascript-typescript-langserver
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :config (setq js2-basic-offset 2))

  (use-package lsp-javascript-typescript
    :disabled t
    :init
    (defun vj--lsp-javascript-typescript-enable ()
      (unless (file-remote-p default-directory)
        (require 'lsp-javascript-typescript)
        (lsp-javascript-typescript-enable)))
    :hook (js2-mode . vj--lsp-javascript-typescript-enable))
#+END_SRC

Use [[https://github.com/magnars/js2-refactor.el][js2-refactor]] for refactoring support.

#+BEGIN_SRC emacs-lisp
  (use-package js2-refactor
    :after (js2-mode hydra)
    :hook (js2-mode . js2-refactor-mode)
    :bind ("C-c <C-m>" . js2-refactor-hydra/body)
    :config
    ;; Hydra copied from https://gist.github.com/anachronic/7af88c62db136727cd1fed17ee0a662f
    (defhydra js2-refactor-hydra (:color blue :hint nil)
      "
  ^Functions^                    ^Variables^               ^Buffer^                      ^sexp^               ^Debugging^
  ------------------------------------------------------------------------------------------------------------------------------
  [_lp_] Localize Parameter      [_ev_] Extract variable   [_wi_] Wrap buffer in IIFE    [_k_]  js2 kill      [_lt_] log this
  [_ef_] Extract function        [_iv_] Inline variable    [_ig_] Inject global in IIFE  [_ss_] split string  [_dt_] debug this
  [_ip_] Introduce parameter     [_rv_] Rename variable    [_ee_] Expand node at point   [_sl_] forward slurp
  [_em_] Extract method          [_vt_] Var to this        [_cc_] Contract node at point [_ba_] forward barf
  [_ao_] Arguments to object     [_sv_] Split var decl.    [_uw_] unwrap
  [_tf_] Toggle fun exp and decl [_ag_] Add var to globals
  [_ta_] Toggle fun expr and =>  [_ti_] Ternary to if
  [_q_]  quit"
      ("ee" js2r-expand-node-at-point)
      ("cc" js2r-contract-node-at-point)
      ("ef" js2r-extract-function)
      ("em" js2r-extract-method)
      ("tf" js2r-toggle-function-expression-and-declaration)
      ("ta" js2r-toggle-arrow-function-and-expression)
      ("ip" js2r-introduce-parameter)
      ("lp" js2r-localize-parameter)
      ("wi" js2r-wrap-buffer-in-iife)
      ("ig" js2r-inject-global-in-iife)
      ("ag" js2r-add-to-globals-annotation)
      ("ev" js2r-extract-var)
      ("iv" js2r-inline-var)
      ("rv" js2r-rename-var)
      ("vt" js2r-var-to-this)
      ("ao" js2r-arguments-to-object)
      ("ti" js2r-ternary-to-if)
      ("sv" js2r-split-var-declaration)
      ("ss" js2r-split-string)
      ("uw" js2r-unwrap)
      ("lt" js2r-log-this)
      ("dt" js2r-debug-this)
      ("sl" js2r-forward-slurp)
      ("ba" js2r-forward-barf)
      ("k" js2r-kill)
      ("q" nil))
  )
#+END_SRC

** elisp
I don't like to have =checkdoc= warning in elisp with =flycheck=

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'flycheck
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

*** edebug
Use tracing with edebug, hit =T=:

#+BEGIN_SRC emacs-lisp
  (setq edebug-trace t)
#+END_SRC

** eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish eldoc-mode
    :hook ((c-mode-common emacs-lisp-mode lisp-interaction-mode-hook) . eldoc-mode))
#+END_SRC

** lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

** ibuffer

Use ibuffer instead of list-buffers.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :commands ibuffer
    :bind ("C-x C-b" . ibuffer))
#+END_SRC

Use [[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] to add version control information and project grouping
to =ibuffer=.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :after ibuffer
    :commands ibuffer-vc-set-filter-groups-by-vc-root
    :config
    (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process))
        ibuffer-show-empty-filter-groups nil)
    :hook (ibuffer . (lambda ()
                       (setq ibuffer-filter-groups
                             (append
                              '(
                                ("Emacs"
                                 (or
                                  (name . "^\\*scratch\\*$")
                                  (name . "^\\*Messages\\*$")))
                                ("Special buffers"
                                 (name . "^\\*.*\\*$")))
                              (ibuffer-vc-generate-filter-groups-by-vc-root)))
                       (unless (eq ibuffer-sorting-mode 'alphabetic)
                         (ibuffer-do-sort-by-filename/process))
                       (ibuffer-update nil t))))
#+END_SRC

** wgrep

For mass editing search results. [[Ivy]] also supports =wgrep= so keep it
loaded.

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :defer 5)
#+END_SRC

** json

Use a proper [[https://github.com/joshwnj/json-mode][json-mode]] instead of =j2-mode=. Prettier colors and a
formatter.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json$")
#+END_SRC

Also install [[https://github.com/Sterlingg/json-snatcher][json-snatcher]] for getting those json paths easily.

#+BEGIN_SRC emacs-lisp
  (use-package json-snatcher
    :commands jsons-print-path)
#+END_SRC

** nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode "\\.nix$")
#+END_SRC

** text-mode

#+BEGIN_SRC emacs-lisp
  (use-package text-mode
    :ensure nil
    :hook (text-mode . auto-fill-mode))
#+END_SRC

** deadgrep

Try out [[https://github.com/Wilfred/deadgrep][deadgrep]] for fast grepping with a easy to use UI.

#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :bind ("M-s d" . deadgrep))
#+END_SRC

** treemacs

Use [[https://github.com/Alexander-Miller/treemacs][treemacs]] as a project browser. I usually don't use tree browsers, but it's
greate when exploring a project I'm not familiar with.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :commands treemacs)

  (use-package treemacs-projectile
    :after treemacs
    :commands treemacs-projectile)
#+END_SRC

* Minor Modes
** amx

M-x replacement. Using it to augment =counsel-M-x=. Fork of smex.

#+BEGIN_SRC emacs-lisp
  (use-package amx
    :defer 5
    :commands amx
    :bind ("M-X" . amx-major-mode-commands))
#+END_SRC

** Ivy

I have used [[https://github.com/emacs-helm/helm][Helm]] as a global completion and UI overhaul of emacs. I
like it, but it feels like a really complicated beast, and I'm
forgetting keybindings and stuff it can do. I'm going to try out
[[https://github.com/abo-abo/swiper][Ivy]]/Counsel this time. Which is a simple auto completion package, with
extra packages that does many of the things Helm does, but in a
seemingly simpler way.

Ivy, Swiper and Counsel are kind of interleaved, so I'm not sure where
I should enable what. But the following works. =:demand= is used to
force loading of the packages.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ""
    :demand t
    :init
    (setq ivy-use-virtual-buffers t
          ivy-height 20
          ivy-fixed-height-minibuffer t
          ivy-count-format "%d/%d "
          ; don't use an initial input for ivy
          ivy-initial-inputs-alist nil
          ; allow regexp in any order
          ivy-re-builders-alist '((t . ivy--regex-ignore-order))
          ivy-dynamic-exhibit-delay-ms 200
          ivy-use-selectable-prompt t
          ivy-format-function #'ivy-format-function-line
          ivy-magic-tilde nil)
    :bind (
           ("C-c C-r" . ivy-resume)
           :map ivy-minibuffer-map
                ("<up>" . ivy-previous-line-or-history))
    :config
    (ivy-mode 1))
#+END_SRC

Add =ivy-hydra= to enable augmented UI features in swiper/counsel.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-hydra
    :after ivy)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :after ivy
    :commands (swiper swiper-all)
    :bind (
           ("M-s s" . counsel-grep-or-swiper)
           ("C-c v" . ivy-push-view)
           ("C-c V" . ivy-pop-view)
           :map isearch-mode-map
           ("C-o" . swiper-from-isearch)
           ("C-M-s" . swiper-from-isearch)
           :map swiper-map
           ("C-'" . swiper-avy)
           ("M-c" . haba/swiper-mc-fixed))
    :config
    ;; https://github.com/abo-abo/swiper/issues/1304
    (defun haba/swiper-mc-fixed ()
      (interactive)
      (setq swiper--current-window-start nil)
      (swiper-mc)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :demand t
    :after ivy
    :commands (counsel-minibuffer-history counsel-apropos
               counsel-bookmark counsel-describe-face
               counsel-describe-function counsel-describe-variable
               counsel-descbinds counsel-M-x counsel-find-file
               counsel-find-library counsel-yank-pop
               counsel-info-lookup-symbol counsel-imenu
               counsel-recentf)
    :config
    (setq counsel-find-file-at-point t)
    :bind (([remap apropos]                  . counsel-apropos)
           ([remap bookmark-jump]            . counsel-bookmark)
           ([remap describe-face]            . counsel-describe-face)
           ([remap describe-function]        . counsel-describe-function)
           ([remap describe-variable]        . counsel-describe-variable)
           ([remap describe-bindings]        . counsel-descbinds)
           ([remap execute-extended-command] . counsel-M-x)
           ([remap find-file]                . counsel-find-file)
           ([remap find-library]             . counsel-find-library)
           ([remap yank-pop]                 . counsel-yank-pop)
           ([remap info-lookup-symbol]       . counsel-info-lookup-symbol)
           ([remap imenu]                    . counsel-imenu)
           ([remap recentf-open-files]       . counsel-recentf))
    :bind (("C-h C-h" . counsel-M-x)
           ("M-s a" . counsel-ag)
           ("M-s g" . counsel-git-grep)
           ("M-s f" . counsel-file-jump)
           ("M-i" . counsel-imenu)))
#+END_SRC

Add my own Counsel extensions.

#+BEGIN_SRC emacs-lisp
  (use-package my-counsel
    :after counsel
    :load-path "site-lisp/counsel/"
    :bind ("C-c i" . counsel-all-mark-ring))
#+END_SRC

Ivy's switch buffer is quite bare after getting used to Helm. [[https://github.com/Yevgnen/ivy-rich][ivy-rich]]
makes it closer to Helm.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :demand t
    :after (ivy)
    :init
    (setq
     ivy-virtual-abbreviate 'full
     ivy-rich-switch-buffer-align-virtual-buffer t
     ivy-rich-switch-buffer-name-max-length 40
     ivy-rich-path-style 'abbrev)
    :config
    (ivy-rich-mode 1))
#+END_SRC

Use Ivy for xref.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-xref
    :after (ivy xref)
    :config (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

Use [[https://github.com/PythonNut/historian.el][historian]] to get result matching based on history.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-historian
    :demand t
    :after ivy
    :config (ivy-historian-mode t))
#+END_SRC

** avy

Bundle of movement stuff.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :demand t
    :config (avy-setup-default)
    :bind ("C-'" . avy-goto-char-timer))
#+END_SRC

** smartparens

I have had a bit of trouble with [[https://github.com/Fuco1/smartparens][smartparens]] outside of lispy stuff,
but still it seems I cannot live without it anymore.

Copied some of the smartparens configuration from [[https://github.com/raxod502/radian/blob/master/emacs/modules/radian-pairs.el][radian-pairs.el]]
(MIT License -- Copyright (c) 2016 Radon Rosborough)

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :defer 5
    :diminish smartparens-mode
    :config
    (require 'smartparens-config)
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)
    (sp-use-smartparens-bindings)
    ;; Don't use Emacs matching paren blink as smartparens does something
    ;; similar.
    (setq blink-matching-paren nil)

    (defun vj--sp-strict-kill-region-or-whole-line ()
      (interactive
       (if mark-active
           (sp-kill-region (region-beginning) (region-end))
         ;; Could not use sp-kill-whole-line here as it leaves an empty
         ;; line in the kill-ring
         (progn
           (beginning-of-line)
           (sp-kill-hybrid-sexp nil)))))
    (define-key smartparens-strict-mode-map
      [remap kill-region] #'vj--sp-strict-kill-region-or-whole-line)
    (define-key smartparens-mode-map (kbd "M-<backspace>") nil)

    (dolist (mode sp-lisp-modes)
      (let ((mode-hook (intern (format "%S-hook" mode))))
        (add-hook mode-hook #'smartparens-strict-mode)))

    ;; Disable smartparens in org-stuff
    (with-eval-after-load 'org
      (add-to-list 'sp-ignore-modes-list #'org-mode))

    (with-eval-after-load 'org-agenda
      (add-to-list 'sp-ignore-modes-list #'org-agenda-mode))

    (defun radian-enter-and-indent-sexp (&rest _ignored)
      "Insert an extra newline after point, and reindent."
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))

    (dolist (mode '(c-mode c++-mode css-mode objc-mode java-mode
                           js2-mode json-mode
                           python-mode sh-mode web-mode))
      (sp-local-pair mode "{" nil :post-handlers
                     '((radian-enter-and-indent-sexp "RET")
                       (radian-enter-and-indent-sexp "<return>"))))

    (dolist (mode '(js2-mode json-mode python-mode web-mode))
      (sp-local-pair mode "[" nil :post-handlers
                     '((radian-enter-and-indent-sexp "RET")
                       (radian-enter-and-indent-sexp "<return>"))))

    (dolist (mode '(python-mode))
      (sp-local-pair mode "(" nil :post-handlers
                     '((radian-enter-and-indent-sexp "RET")
                       (radian-enter-and-indent-sexp "<return>")))
      (sp-local-pair mode "\"\"\"" "\"\"\"" :post-handlers
                     '((radian-enter-and-indent-sexp "RET")
                       (radian-enter-and-indent-sexp "<return>")))))
#+END_SRC

** diff-hl-mode

Shows VC status at the left margin with a hook for =magit= to refresh
the status when =magit= refreshes.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer 5
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode))
#+END_SRC

** uniquify

I don't like the default buffer name uniquefier style, which appends
directory at the end of a non-unique buffer name, e.g. ~foo<bar/quux>~
and ~foo<something/else>~. So set the style to =forward=, which skips
the greatest common denominator directory:

#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-min-dir-content 2)
#+END_SRC

** expand-region

This is a game changer of text editing in Emacs for me. In a way it
replaces Vim's motion stuff for me, but visually.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("M-[" . er/contract-region)
           ("M-]" . er/expand-region)))
#+END_SRC

** multiple-cursors

After getting used to this, I use it more often than search&replace
facilities. Except that it has a lot of compatibilty issues with
different modes.

mc shortcuts copied from:
https://github.com/jwiegley/dot-emacs/blob/8e669ab1aa420486d93276db2de8fb0c0948cd6d/init.el#L2643


#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :after (selected phi-search)
    :defer 5
    :bind (("C-<" . mc/mark-previous-like-this)
           ("C->" . mc/mark-next-like-this)
           ("C-*" . mc/mark-all-like-this)
           ("S-<down-mouse-1>")
           ("S-<mouse-1>" . mc/add-cursor-on-click))
    :bind (:map mc/keymap
                ("C-s" . phi-search)
                ("C-r" . phi-search-backward))
    :bind (:map selected-keymap
                ("c"   . mc/edit-lines)
                ("*"   . mc/mark-all-like-this)
                ("."   . mc/mark-next-like-this)
                ("<"   . mc/unmark-next-like-this)
                ("C->" . mc/skip-to-next-like-this)
                (","   . mc/mark-previous-like-this)
                (">"   . mc/unmark-previous-like-this)
                ("C-<" . mc/skip-to-previous-like-this)
                ("y"   . mc/mark-next-symbol-like-this)
                ("Y"   . mc/mark-previous-symbol-like-this)
                ("w"   . mc/mark-next-word-like-this)
                ("W"   . mc/mark-previous-word-like-this)
                ("?"   . mc-hide-unmatched-lines-mode)))
#+END_SRC

** phi-search

Use [[https://github.com/zk-phi/phi-search][phi-search]] as an isearch replacement when doing [[multiple-cursors][multiple-cursors]] stuff, as
isearch doesn't work there. Not yet going to replace isearch though.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :defer 5)

  (use-package phi-search-mc
    :after (phi-search multiple-cursors)
    :config
    (phi-search-mc/setup-keys)
    (add-hook 'isearch-mode-mode #'phi-search-from-isearch-mc/setup-keys))
#+END_SRC

** undo-tree

Handle undo as a tree. More intuitive than emacs default for me.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :demand t
    :bind (:map undo-tree-map
                ("C-/" . nil))
    :config
    (global-undo-tree-mode)
    (setq undo-tree-auto-save-history nil))
#+END_SRC

** winner-mode
Let's me undo and redo window configurations.

#+BEGIN_SRC emacs-lisp
  (winner-mode t)
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 15
          recentf-auto-cleanup 'never)
    (recentf-mode t))
#+END_SRC

** company

Use [[https://github.com/company-mode/company-mode][company-mode]] for auto completion.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer 5
    :diminish company-mode
    :hook (after-init . global-company-mode)
    :bind (("M-/" . company-complete)
           ("C-/" . company-yasnippet))
    :config
    (setq company-minimum-prefix-length 2
          company-selection-wrap-around t
          company-show-numbers t
          company-tooltip-align-annotations t
          company-require-match nil
          company-dabbrev-downcase nil
          company-dabbrev-ignore-case nil))
#+END_SRC

Use [[https://github.com/expez/company-quickhelp][company-quickhelp]] to show documentation of the completion
candidate.

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :after company
    :demand t
    :bind (:map company-active-map
                ("C-c h" . company-quickhelp-manual-begin))
    :config
    (company-quickhelp-mode))
#+END_SRC

** fringe-helper

Customize fringe bitmaps with [[https://github.com/nschum/fringe-helper.el][fringe-helper]].

#+BEGIN_SRC emacs-lisp
  (use-package fringe-helper
    :commands fringe-helper-define)
#+END_SRC

** flycheck

Flycheck is a nice on the fly syntax / compilation checker. Fringe
copied from [[https://github.com/hlissner/doom-emacs][doom-emacs]].

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish global-flycheck-mode
    :hook ((emacs-lisp-mode . flycheck-mode)
           (prog-mode-hook . flycheck-mode)
           (c++-mode-hook . (lambda () (setq flycheck-clang-language-standard "c++11"))))
    :commands (flycheck-mode flycheck-next-error flycheck-previous-error)
    :config
    (setq flycheck-indication-mode 'right-fringe)
    (fringe-helper-define 'flycheck-fringe-bitmap-double-arrow 'center
      "...X...."
      "..XX...."
      ".XXX...."
      "XXXX...."
      ".XXX...."
      "..XX...."
      "...X...."))
#+END_SRC

** whitespace

I like to see mistakes with indentation clearly.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :diminish global-whitespace-mode
    :config
    (setq whitespace-style (quote (face indentation:space trailing tabs tab-mark)))
    (global-whitespace-mode t))
#+END_SRC

** which-key

Show a help window with modal commands.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :defer 5
    :commands which-key-mode
    :config (which-key-mode))
#+END_SRC

** saveplace

Remember where I was when I last saved.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config
    (save-place-mode 1))
#+END_SRC

** ace-window

Used for moving quicky between windows.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :disabled t
    :commands ace-window
    :bind (("C-x o" . ace-window)
           ("C-\\" . ace-window))
    :config
    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l)
          aw-background nil)
    :custom-face
    (aw-leading-char-face ((t (:foreground "3a3a3a" :weight bold :height 3.0)))))
#+END_SRC

** switch-window

Used for moving visually between windows. I've been having problems with
[[ace-window]] not showing the switch characters for all the windows. There is
some discussion going on at [[https://github.com/abo-abo/ace-window/issues/131][Github]]. Trying out [[https://github.com/dimitri/switch-window][switch-window]] as an alternative
for now.

Sadly this mode doesn't show the contents.

#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :bind (("C-x o" . switch-window)
           ("C-\\" . switch-window)
           ("C-1" . switch-window-then-maximize)
           ("C-2" . switch-window-then-split-below)
           ("C-3" . switch-window-then-split-right)
           ("C-0" . switch-window-then-delete))
    :config
    (setq switch-window-shortcut-style 'qwerty
          switch-window-qwerty-shortcuts '("a" "s" "d" "f" "j" "k" "l" ";" "w" "e" "i" "o")
          switch-window-increase 1
          switch-window-threshold 2
          switch-window-minibuffer-shortcut ?z))
#+END_SRC
** visual-regexp

[[https://github.com/benma/visual-regexp.el][visual-regexp]] for easier regexp replace.

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :commands (vr/replace vr/query-replace vr/mc-mark)
    :bind (("C-c r" . vr/replace)
           ("C-c q" . vr/query-replace)
           ("C-c m" . vr/mc-mark)))
#+END_SRC

** eglot

Try [[https://github.com/joaotavora/eglot][eglot]] for my LSP needs. It seems to be simpler than [[lsp-mode]]. Most
important feature in eglot vs. lsp-mode is that it can handle LSP server
shutdowns more gracefully (and can restart them automatically).

Requires Emacs 26.1.

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :after (company company-quickhelp)
    :commands eglot
    :preface
    ;; Patch to shutdown eglot, because of the yes-no advice is not enough
    (with-eval-after-load 'projectile
      (with-eval-after-load 'eglot
        (el-patch-defun projectile-kill-buffers ()
          "Kill all project buffers."
          (interactive)
          (let ((name (projectile-project-name))
                (buffers (projectile-project-buffers)))
            (if (yes-or-no-p
                 (format "Are you sure you want to kill %d buffer(s) for '%s'? "
                         (length buffers) name))
                ;; we take care not to kill indirect buffers directly
                ;; as we might encounter them after their base buffers are killed
                (mapc (el-patch-swap
                        #'kill-buffer
                        (lambda (buffer)
                          (ignore-errors
                            (when-let* ((server (eglot--current-server)))
                              (eglot-shutdown server)))
                          (kill-buffer buffer)))
                      (cl-remove-if 'buffer-base-buffer buffers)))))))
    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs '(typescript-mode . ("javascript-typescript-stdio")))))
#+END_SRC

** lsp-mode

Try out [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] for language support. It's a Microsoft Language
Server Protocol library.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :disabled t
    :defer 5)

  (use-package company-lsp
    :after (company lsp-mode))
#+END_SRC

** lsp-ui

Add some =lsp-mode= specific UI features. Because =lsp-ui-doc-mode= only
supports Emacs 26 (and greater), it's limited by that.

Not really sure if I like them, but just trying them out here.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :disabled t
    :after lsp-mode
    :if (>= emacs-major-version 26)
    :hook (lsp-mode . lsp-ui-mode))
#+END_SRC

** dumb-jump

[[https://github.com/jacktasia/dumb-jump][dumb-jump]] is a navigation tool, that uses some regex magic and the
best available grepping tool to find symbols in a project. The idea is
quite nice, as harddrives and greppers are so fast, that in many cases
you don't actually need indexing.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :after smart-jump
    :config
    (setq dumb-jump-selector 'ivy))
#+END_SRC

** smart-jump

Combine all the navigation tools under a single umbrella with
[[https://github.com/jojojames/smart-jump][smart-jump]].

#+BEGIN_SRC emacs-lisp
  (use-package smart-jump
    :defer 5
    :commands smart-jump-go
    :config
    (smart-jump-setup-default-registers)
    ;; Replace the default elisp registration as I don't have slime and it doesn't
    ;; work without it
    (smart-jump-register :modes '(emacs-lisp-mode lisp-interaction-mode))
    ;; Also add js2-mode mode, as the defaults requires rjsx-mode?
    (with-eval-after-load 'js2-mode
      (smart-jump-register :modes '(js2-mode))))
#+END_SRC

** try

Use [[https://github.com/larstvei/Try][Try]] for testing out packages.

#+BEGIN_SRC emacs-lisp
  (use-package try
    :commands try
    :init
    (eval-after-load "try" #'package-initialize))
#+END_SRC

** free-keys

[[https://github.com/Fuco1/free-keys][free-keys]] is a simple tool to list free keybindings in the current
buffer.

#+BEGIN_SRC emacs-lisp
  (use-package free-keys
    :commands free-keys)
#+END_SRC

** imenu-list

[[https://github.com/bmag/imenu-list][imenu-list]] provides a nice buffer view into the current =imenu=. I
haven't really used =imenu= that much, but I can see this being useful
in some cases.

#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :commands imenu-list-minor-mode)
#+END_SRC

** yasnippet

I usually don't use snippets in Emacs. But I do in Intellij IDEA. So
let's try using them them again. This time with a lot of ready made
snippets, and a quick snippet creation mode: [[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]]

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :commands (yas-minor-mode yas-minor-mode-on yas-expand
               yas-expand-snippet yas-lookup-snippet
               yas-insert-snippet yas-new-snippet
               yas-visit-snippet-file snippet-mode)
    :preface
    (defvar yas-minor-mode-map (make-sparse-keymap))
    :init
    (defun vj--yas-reload-all-hook ()
      (yas-reload-all)
      (remove-hook 'yas-minor-mode-hook 'vj--yas-reload-all-hook))
    (add-hook 'yas-minor-mode-hook 'vj--yas-reload-all-hook)
    :hook ((text-mode . yas-minor-mode-on)
           (prog-mode . yas-minor-mode-on)
           (snippet-mode . yas-minor-mode-on))
    :config
    (setq yas-trigger-in-field t)
    ;; Fix smartparens conflict
    (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay))

  (use-package yasnippet-snippets
    :after yasnippet)

  (use-package auto-yasnippet
    :after yasnippet
    :commands (aya-create aya-expand aya-open-line aya-persist-snippet)
    :bind (("C-c y a" . aya-create)
           ("C-c y e" . aya-expand)
           ("C-c y o" . aya-open-line)))
#+END_SRC

** crux

[[https://github.com/bbatsov/crux][crux]] is a collection of nice little tools for Emacs. Some of them are
ones I had custom functions, but can now use =crux= version of them,
which should be better maintained.

It's really slow to load though.

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :defer 5
    :bind* (("C-o" . crux-smart-open-line)
            ("C-S-o" . crux-smart-open-line-above)
            ("C-a" . crux-move-beginning-of-line)))
#+END_SRC

** whole-line-or-region

Use [[https://github.com/purcell/whole-line-or-region][whole-line-or-region]] to bind actions such as kill/yank to work on
the whole line when there is no region active. [[crux][crux]] could handle this
with it's advices, but I want to defer it as it's really slow to load,
but still have the functionality available.

I'm replacing this with [[phi-rectangle][phi-rectangle]] for now. It has the same feature as this
one with some nice extras.

#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :disabled t
    :unless noninteractive
    :demand t
    :diminish whole-line-or-region-local-mode
    :config
    (whole-line-or-region-global-mode 1))
#+END_SRC

** phi-rectangle

[[https://github.com/zk-phi/phi-rectangle][phi-rectangle]] augments killing and yanking in a couple of important ways:

1. Kills whole line if there is no region
2. Supports [[multiple-cursors][multiple-cursors]]
3. Yank chooses automatically between yank and yank-rectangle, so I don't have
   to.

#+BEGIN_SRC emacs-lisp
  (use-package phi-rectangle
    :after multiple-cursors
    :config
    (phi-rectangle-mode 1))
#+END_SRC

** selected

[[https://github.com/Kungsgeten/selected.el][selected]] is a tool for rebinding keys while a selection is active. It
means that I cannot type over a selection, but makes doing stuff with
selections much easier on the fingers.

#+BEGIN_SRC emacs-lisp
  (use-package selected
    :defer 5
    :diminish selected-minor-mode
    :commands selected-minor-mode
    :bind (:map selected-keymap
                ("q" . selected-off)
                ("<tab>" . indent-region)
                ("m" . apply-macro-to-region-lines))
    :config
    (selected-global-mode t))
#+END_SRC

** symbol-overlay

Use [[https://github.com/wolray/symbol-overlay][symbol-overlay]] to mainly navigate between symbols in the current
buffer. I previously used [[https://github.com/mickeynp/smart-scan][smart-scan]] for that, but symbol-overlay can
also provide additional features such as highlighting symbols.

#+BEGIN_SRC emacs-lisp
  (use-package symbol-overlay
    :diminish symbol-overlay-mode
    :hook ((prog-mode-hook . symbol-overlay-mode)
           (html-mode-hook . symbol-overlay-mode)
           (css-mode-hook . symbol-overlay-mode))
    :bind (("M-n" . symbol-overlay-jump-next)
           ("M-p" . symbol-overlay-jump-prev)
           ("C-c o" . symbol-overlay-put)))
#+END_SRC

** shackle

Control Emacs buffers with [[https://github.com/wasamasa/shackle][shackle]].

#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :demand t
    :config
    (setq
     shackle-default-rule '(:select t)
     shackle-rules '(("\\`\\*Flycheck" :regexp t :size 0.2 :noselect t :align bottom)
                     ("\\`\\*Flymake" :regexp t :size 0.2 :noselect t :align bottom)
                     ("*Warnings*" :size 0.2 :noselect t :align bottom)
                     ("\\`\\*COMMIT_EDITMSG" :regexp t :size 0.5 :align right)
                     (magit-diff-mode :noselect t :align bottom :size 0.5)
                     (magit-commit-mode :ignore t)
                     ("*edebug-trace*" :size 0.2 :align bottom)
                     ("*Messages*" :select t :size 0.4 :align t)
                     (compilation-mode :noselect t :size 0.4 :align t)))
    (shackle-mode))
#+END_SRC

** eyebrowse

I'm working on multiple project all the time in Emacs. My buffers are
all over the place. Try using [[https://github.com/wasamasa/eyebrowse][eyebrowse]] to handle it.

#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :demand t
    :config
    (setq
     eyebrowse-mode-line-separator ""
     eyebrowse-new-workspace t)
    (eyebrowse-mode t))
#+END_SRC

** ansible

Add autocomplete for Ansible.

#+BEGIN_SRC emacs-lisp
  (use-package company-ansible
    :after company
    :config
    (with-eval-after-load 'company
      (add-to-list 'company-backends 'company-ansible)))
#+END_SRC

** macrostep

It's nice to see what a elisp macro does sometimes. [[https://github.com/joddie/macrostep][macrostep]] is a
nice tool for that.

#+BEGIN_SRC emacs-lisp
  (use-package macrostep
    :bind (:map emacs-lisp-mode-map
           ("C-c e" . macrostep-expand)))

#+END_SRC

** helpful

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-key)
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)
           ("C-c C-d" . helpful-at-point)
           ("C-h F" . helpful-function)
           ("C-h C" . helpful-command)))
#+END_SRC

** isearch

#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :ensure nil
    :config
    (setq lazy-highlight-initial-delay 0)
    :bind (("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp)
           ("C-M-r" . isearch-backward)))
#+END_SRC

** xterm-color

Add support for ANSI control sequences. It should be better than the included
=ansi-color.el=. Configuration mostly copied from [[https://github.com/atomontage/xterm-color][xterm-color]] github page.

#+BEGIN_SRC emacs-lisp
  (use-package xterm-color
    :demand t
    :config
    (with-eval-after-load 'comint
      (setq comint-output-filter-functions
            (remove 'ansi-color-process-output comint-output-filter-functions)))
    (with-eval-after-load 'shell
      (add-hook 'shell-mode-hook
                (lambda () (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t))))

    (with-eval-after-load 'esh-mode
      (add-hook 'eshell-before-prompt-hook
                (lambda ()
                  (setenv "TERM" "xterm-256color")
                  (setq xterm-color-preserve-properties t)))
      (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
      (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions)))

    (with-eval-after-load 'compile
      (setq compilation-environment '("TERM=xterm-256color"))
      (add-hook 'compilation-start-hook
                (lambda (proc)
                  ;; We need to differentiate between compilation-mode buffers
                  ;; and running as part of comint (which at this point we assume
                  ;; has been configured separately for xterm-color)
                  (when (eq (process-filter proc) 'compilation-filter)
                    ;; This is a process associated with a compilation-mode buffer.
                    ;; We may call `xterm-color-filter' before its own filter function.
                    (set-process-filter
                     proc
                     (lambda (proc string)
                       (funcall 'compilation-filter proc
                                (xterm-color-filter string))))))))
    )
#+END_SRC

** dtrt-indent

Try to guess buffer indentation settings with [[https://github.com/jscheid/dtrt-indent][dtrt-indent]].

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :diminish ""
    :hook (prog-mode . dtrt-indent-mode)
    :config
    (add-to-list 'dtrt-indent-hook-mapping-list '(typescript-mode javascript typescript-indent-level)))

#+END_SRC

** direnv

Use [[https://github.com/wbolster/emacs-direnv][emacs-direnv]] to setup buffer environment using [[https://github.com/direnv/direnv][direnv]].

#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :if (not (eq system-type 'windows-nt))
    :diminish
    :config
    (direnv-mode))
#+END_SRC

** pos-tip

Fix pos-tip behavior on macOS.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'pos-tip
    (if (eq system-type 'darwin)
        (setq pos-tip-use-relative-coordinates t)))
#+END_SRC

* Emacs server
#+BEGIN_SRC emacs-lisp
  (use-package server
    :unless noninteractive
    :no-require
    :hook (after-init . server-start))
#+END_SRC

